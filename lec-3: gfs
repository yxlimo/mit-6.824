# lec 3: GFS
#6.824#
## 前言
本节主要通过讲述 GFS 的实现方式来接触一些分布式相关的基础问题，同时也是比较经典的问题
## 怪圈（为什么很难实现一个完美的强一致性的分布式系统）
设计分布式系统的初衷是为了提高程序的性能，单台机器性能有限，所以需要多台机器并行计算；
机器一多，机器故障就成了常态，今天这个硬盘坏了，明天那个网卡坏了，所以系统需要能够做到容忍错误（fault tolerance）；
实现容错的方案似乎只有数据冗余这一个选择，同一份数据分散在多个机器上，单独机器损坏不会导致数据丢失；
因为数据一式多份的存储，就涉及到了数据一致性问题，为了让数据一致，在数据更改时需要 server 之间互相通信，而这又降低了性能。
## GFS 的处理方式
整体上感觉还是由主备的思想演化而来，不算太正经的分布式系统，在当时大概是对成本做出了取舍
### Master 和 Chunk Server 的通信
Master 负责管理 N 多个 Chunk 与 Chunk Server 之间的对应关系，Client 会去询问 master 它所需要的 chunk 在哪些 Server 上，并与这些 Server 进行后续通信。为了实现简单，Master 是单点的，只是通过日志以及部分数据持久化来处理崩溃后的恢复问题。而单点的性能问题则通过尽量减少通信解决，解决方案是把大部分逻辑下放到 Chunk Server
### Primary and Secondaries
因为有 master 这个中心化的主节点存在，Chunk 节点的主备也会简单很多。master 会决定某个 chunk server 为 Primary，并由 Primary 来主导整个数据写入的过程（选主的过程以及选主之后的容错处理由租约机制去保证）。Client 会请求 Primary 写入数据，Primary 再通知 Secondaries 去写入数据，当 Secondaries 全部写入成功后，Primary 才会返回成本，否则就需要 Client 去反复重试。（这里没有处理永久性损坏的情况，需要把损坏的 Server直接移除，也没有保证数据的一致性）
