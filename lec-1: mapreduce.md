# MapReduce note
## 前言
自从人类的科技树由高性能单体逐渐发展成由低性能集群，管理一定数量级的机器就成了行业一直以来的难题。一方面由于机器数量的提升导致硬件故障从偶然变成了必然，另一方面数据的计算存储也不是单纯地加机器就能拓展的，如何让多台机器最大化地发挥性能也是个难题。在这个背景下，Google 三架马车之一，针对大数据计算的 MapReduce 诞生了。
## 什么是 MapReduce
一个针对大数据（TB级甚至 PB 级）的分布式处理框架，通过将数据分隔成 N 份，分别经过 Map 函数处理，变成 kv 的数据结构，再输入到 Reduce 函数进行聚合。开发者只需要自定义 Map 和 Reduce 函数，不需要关心机器的调度，容错等，专注在业务逻辑，提高效率。
## 它是如何运转的
![mapreduce](http://www-x-habadog-x-com.img.abc188.com/wp-content/uploads/2011/05/mapreduce-excution.jpg)
如图，核心是个 master，负责分割数据并调度 worker，每个 worker 都一台机器，可以跑 N 个 Map 或 N 个 Reduce。master 分割完数据后，会分别输入到 Map 函数，Map 函数完成计算并输出到 GFS（或者直接输出到本地磁盘），并通知 master 计算完毕以及结果文件的位置。之后 master 调用 Reduce 处理 Map 输出的结果并输出最终结果，当所有的 task 执行完毕，master 会通知用户线程并返回结果。
## 容错机制
说分布式就一定逃不开错误处理，各种边角 case，由于 MapReduce 架构还算比较简单，task之间相互独立，互不影响。所以无需特别复杂的错误处理，论文说的也比较简单。主要考虑机器挂了的情况，比如 Worker 无响应的情况下，无论它有没有完成计算，master都会调用其他 Worker 来处理这一份数据。如果 master 挂了（没错，master 是单点），那就挂了吧，通知用户重试。。。嗯，很业务，很省成本。
## 提升性能小技巧
Worker 除了会挂，还有可能会出现其他的异常情况导致计算特别慢（比如cpu 缓存失效了之类的），这个时候如果有 backup 的 会好很多，当大部分任务都完成的情况下，master 会尝试调用 backup workers 重新处理剩下的还在进行中的 task。哪个先完成就取哪个。
## 总结
大概是论文比较古老的缘故，里面提到的很多解决方案现在看来都属于很常规的解决方案，没有什么亮点。
